using System;
using System.Collections.Generic;
using NUnit.Framework;
using Vts.Common;
using Vts.IO;
using Vts.MonteCarlo;
using Vts.MonteCarlo.Detectors;
using Vts.MonteCarlo.Helpers;
using Vts.MonteCarlo.Sources;
using Vts.MonteCarlo.Tissues;
using Vts.MonteCarlo.PostProcessing;
using Vts.MonteCarlo.PhotonData;

namespace Vts.Test.MonteCarlo.Detectors
{
    /// <summary>
    /// These tests execute perturbation Monte Carlo (pMC) on a discrete absorption weighting (DAW)
    /// MC simulation with 100 seeded photons and verify that 1) on-the-fly and pMC produces same 
    /// (no perturbation) results, and 2) the tally results match the linux results given the same seed
    /// mersenne twister STANDARD_TEST.  The linux results assumes photon passes
    /// through specular and deweights photon by specular.  This test starts photon 
    /// inside tissue and then multiplies result by specular deweighting to match 
    /// linux results. The linux results are generated using the post-processing code in 
    /// the g_post subdirectory.
    /// </summary>
    [TestFixture]
    public class pMCdMCDAWOneLayerDetectorsTests
    {
        private SimulationInput _referenceInputOneLayerTissue;
        private SimulationOutput _referenceOutputOneLayerTissue;
        private double _factor;
        private pMCDatabase _databaseOneLayerTissue;

        private readonly List<string> _listOfTestFiles = new()
        {
            "DiffuseReflectanceDatabase", // name has no "test" prefix, it is generated by the code so name fixed
            "DiffuseReflectanceDatabase.txt",
            "CollisionInfoDatabase",
            "CollisionInfoDatabase.txt",
            "file.txt", // file that captures screen output of MC simulation
        };

        [OneTimeTearDown]
        public void Clear_folders_and_files()
        {
            // make sure databases generated from previous tests are deleted
            foreach (var file in _listOfTestFiles)
            {
                FileIO.FileDelete(file);
            }
        }

        /// <summary>
        /// Define SimulationInput to describe homogeneous one layer case and generate reference database
        /// </summary>
        /// <returns></returns>
        [OneTimeSetUp]
        public void Execute_Monte_Carlo()
        {
            // delete previously generated files
            Clear_folders_and_files();

            var simulationOptions = new SimulationOptions(
                0,
                RandomNumberGeneratorType.MersenneTwister,
                AbsorptionWeightingType.Discrete,
                PhaseFunctionType.HenyeyGreenstein,
                new List<DatabaseType> {DatabaseType.pMCDiffuseReflectance},
                false, // track statistics
                0.0, // RR threshold -> 0 = no RR performed
                0);
            var sourceInput = new DirectionalPointSourceInput(
                new Position(0.0, 0.0, 0.0),
                new Direction(0.0, 0.0, 1.0),
                1);
            var detectorInputs = new List<IDetectorInput>
            {
                new ROfRhoDetectorInput {Rho=new DoubleRange(0.0, 10.0, 101), TallySecondMoment = true},
                new ROfRhoRecessedDetectorInput { Rho=new DoubleRange(0.0, 10.0, 101),ZPlane=-1.0},
                new ROfRhoAndTimeDetectorInput { Rho = new DoubleRange(0.0, 10.0, 101),Time = new DoubleRange(0.0, 1.0, 101)},
                new ROfFxDetectorInput {Fx=new DoubleRange(0.0, 0.5, 11)},
                new ROfFxAndTimeDetectorInput { Fx = new DoubleRange(0.0, 0.5, 11),Time = new DoubleRange(0.0, 1.0, 101)}
 
            };
            _referenceInputOneLayerTissue = new SimulationInput(
                100,
                "", // can't create folder in isolated storage
                simulationOptions,
                sourceInput,
                new MultiLayerTissueInput(
                    new ITissueRegion[]
                    {
                        new LayerTissueRegion(
                            new DoubleRange(double.NegativeInfinity, 0.0),
                            new OpticalProperties(0.0, 1e-10, 1.0, 1.0)),
                        new LayerTissueRegion(
                            new DoubleRange(0.0, 20.0),
                            new OpticalProperties(0.01, 1.0, 0.8, 1.4)),
                        new LayerTissueRegion(
                            new DoubleRange(20.0, double.PositiveInfinity),
                            new OpticalProperties(0.0, 1e-10, 1.0, 1.0))
                    }
                ),
                detectorInputs);
            _factor = 1.0 - Optics.Specular(
                _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP.N,
                _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.N);
            _referenceOutputOneLayerTissue = new MonteCarloSimulation(_referenceInputOneLayerTissue).Run();

            _databaseOneLayerTissue = pMCDatabase.FromFile("DiffuseReflectanceDatabase", "CollisionInfoDatabase");
        }

        /// <summary>
        /// Test to validate that setting mua and mus to the reference values
        /// determines results equal to reference for R(rho,time) and that
        /// R(rho,time) recessed to a height of 0 are equal
        /// </summary>
        [Test]
        public void Validate_pMC_DAW_ROfRhoAndTime_zero_perturbation_one_layer_tissue()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                    new pMCROfRhoAndTimeDetectorInput
                    {
                        Rho=new DoubleRange(0.0, 10.0, 101),
                        Time=new DoubleRange(0.0, 1.0, 101),
                        PerturbedOps=new List<OpticalProperties>
                        {   // set perturbed ops to reference ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> { 1 } 
                    },
                    new pMCROfRhoAndTimeRecessedDetectorInput
                    {
                        Rho=new DoubleRange(0.0, 10.0, 101),
                        Time=new DoubleRange(0, 1.0, 101),
                        ZPlane=0.0,
                        PerturbedOps=new List<OpticalProperties>
                        {   // set perturbed ops to reference ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> { 1 },
                        TallySecondMoment = true
                    },
                },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();

            // validation value obtained from reference non-pMC run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_rt[0, 0] -
                                 _referenceOutputOneLayerTissue.R_rt[0, 0]), 1e-10);
            // validation value obtained from linux run using above input and seeded the same
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_rt[0, 0]*_factor - 61.5238307), 0.0000001);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_rt_TallyCount);

            // validation value obtained from non-pMC non-recessed run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_rtr[0, 0] - 
                                _referenceOutputOneLayerTissue.R_rt[0, 0]), 1e-10);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_rtr_TallyCount);
        }

        /// <summary>
        /// Test to validate that setting mua and mus to the reference values (0 perturbation)
        /// determines results equal to reference for R(rho) and R(rho) recessed
        /// when recessed height=0 for pMC and dMC results
        /// </summary>
        [Test]
        public void Validate_pMC_dMC_DAW_ROfRho_zero_perturbation_one_layer_tissue()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                    new pMCROfRhoDetectorInput
                    {
                        Rho=new DoubleRange(0.0, 10.0, 101),
                        PerturbedOps=new List<OpticalProperties>
                        {   // set perturbed ops to reference ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> { 1 },
                        TallySecondMoment = true
                    },
                    new pMCROfRhoRecessedDetectorInput
                    {
                        Rho=new DoubleRange(0.0, 10.0, 101),
                        ZPlane=0.0,
                        PerturbedOps=new List<OpticalProperties>
                        {   // set perturbed ops to reference ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> { 1 },
                        TallySecondMoment = true
                    },
                    new dMCdROfRhodMuaDetectorInput
                    {
                        Rho=new DoubleRange(0.0, 10, 101),
                        PerturbedOps=new List<OpticalProperties>
                        {   // set perturbed ops to reference ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> {1},
                        TallySecondMoment = true
                    },
                    new dMCdROfRhodMusDetectorInput
                    {
                        Rho=new DoubleRange(0.0, 10, 101),
                        PerturbedOps=new List<OpticalProperties>
                        {   // set perturbed ops to reference ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> {1},
                        TallySecondMoment = true
                    }
                },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();

            // validation value obtained from reference non-pMC run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_r[0] - _referenceOutputOneLayerTissue.R_r[0]), 1e-10);
            // validation value obtained from linux run using above input and seeded the same
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_r[0]*_factor - 0.615238307), 0.000000001);
            // validation value based on previous run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_r2[0] - 20.022918), 0.000001);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_r_TallyCount);

            // validation value obtained from non-pMC non-recessed run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_rr[0] -
                                _referenceOutputOneLayerTissue.R_r[0]), 1e-10);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_rr_TallyCount);

            // validate derivatives with respect to mua and mus with prior run
            Assert.IsTrue(Math.Abs(postProcessedOutput.dMCdMua_R_r[0] + 0.166157) < 1e-6);
            Assert.IsTrue(Math.Abs(postProcessedOutput.dMCdMus_R_r[0] - 0.213279) < 1e-6);
        }

        /// <summary>
        /// Test to validate that setting mua and mus to the perturbed values (mua*2, mus*1.1)
        /// determines results equal to linux results for R(rho)
        /// </summary>
        [Test]
        public void Validate_pMC_dMC_DAW_ROfRho_nonzero_perturbation_one_layer_tissue()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                        new pMCROfRhoDetectorInput
                        {
                            Rho=new DoubleRange(0.0, 10, 101),
                            // set perturbed ops to reference ops
                            PerturbedOps=new List<OpticalProperties>
                            {
                                _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                                new(
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Mua * 2,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Musp * 1.1,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.G,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.N),
                                _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                            },
                            PerturbedRegionsIndices=new List<int> {1},
                            TallySecondMoment = true
                        },
                        new dMCdROfRhodMuaDetectorInput
                        {
                            Rho=new DoubleRange(0.0, 10, 101),
                            // set perturbed ops to reference ops
                            PerturbedOps=new List<OpticalProperties>
                            {
                                _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                                new (
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Mua * 2,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Musp * 1.1,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.G,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.N),
                                _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                            },
                            PerturbedRegionsIndices=new List<int> {1},
                            TallySecondMoment = true
                        },

                        new dMCdROfRhodMusDetectorInput
                        {
                            Rho=new DoubleRange(0.0, 10, 101),
                            // set perturbed ops to reference ops
                            PerturbedOps=new List<OpticalProperties>
                            {
                                _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                                new (
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Mua * 2,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Musp * 1.1,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.G,
                                    _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.N),
                                _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                            },
                            PerturbedRegionsIndices=new List<int> {1},
                            TallySecondMoment = true
                        }
                    },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();

            // validation value obtained from linux run using above input and seeded the same
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_r[0] * _factor - 0.7226588), 0.0000001);
            Assert.IsTrue(Math.Abs(postProcessedOutput.pMC_R_r2[0] - 28.10877) < 1e-4);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_r_TallyCount);
            // validate derivative values with prior run
            Assert.IsTrue(Math.Abs(postProcessedOutput.dMCdMua_R_r[0] + 0.187384) < 1e-6);
            Assert.IsTrue(Math.Abs(postProcessedOutput.dMCdMus_R_r[0] - 0.235936) < 1e-6);
            // and 2nd moments
            Assert.IsTrue(Math.Abs(postProcessedOutput.dMCdMua_R_r2[0] - 1.80735) < 1e-5);
            Assert.IsTrue(Math.Abs(postProcessedOutput.dMCdMus_R_r2[0] - 5.22420) < 1e-5);
        }

        /// <summary>
        /// Test to validate that calling dMC results in not a NaN
        /// </summary>
        [Test]
        public void Validate_dMC_DAW_dROfRhodMua_produces_not_NaN_results()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                    new dMCdROfRhodMuaDetectorInput
                    {
                        Rho = new DoubleRange(0.0, 10, 101),
                        // set perturbed ops to reference ops
                        PerturbedOps = new List<OpticalProperties>
                        {
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices = new List<int> {1}
                    },
                    new dMCdROfRhodMusDetectorInput
                    {
                        Rho = new DoubleRange(0.0, 10, 101),
                        // set perturbed ops to reference ops
                        PerturbedOps = new List<OpticalProperties>
                        {
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices = new List<int> {1}
                    }
                },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();

            // validation value obtained from linux run using above input and seeded the same
            Assert.AreNotEqual(double.NaN, Math.Abs(postProcessedOutput.dMCdMua_R_r[0]));
            Assert.AreNotEqual(double.NaN, Math.Abs(postProcessedOutput.dMCdMus_R_r[0]));
            Assert.AreEqual(89, postProcessedOutput.dMCdMua_R_r_TallyCount);
            Assert.AreEqual(89, postProcessedOutput.dMCdMus_R_r_TallyCount);
        }

        /// <summary>
        /// Test to validate that setting mua and mus to the reference values
        /// determines results equal to reference for R(fx,time)
        /// </summary>
        [Test]
        public void Validate_pMC_DAW_ROfFxAndTime_zero_perturbation_one_layer_tissue()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                    new pMCROfFxAndTimeDetectorInput
                    {
                        Fx=new DoubleRange(0.0, 0.5, 11),
                        Time=new DoubleRange(0.0, 1.0, 101),
                        PerturbedOps=new List<OpticalProperties>
                        { // perturbed ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> { 1 } 
                    }  
                },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();

            // validation value obtained from reference non-pMC run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fxt[1, 0].Real -
                                 _referenceOutputOneLayerTissue.R_fxt[1, 0].Real), 0.00000000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fxt[1, 0].Imaginary -
                     _referenceOutputOneLayerTissue.R_fxt[1, 0].Imaginary), 0.00000000001);
            // validation value obtained from prior run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fxt[1, 0].Real - 6.858014), 0.000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fxt[1, 0].Imaginary - 0.339772), 0.000001);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_fxt_TallyCount);
        }

        /// <summary>
        /// Test to validate that setting mua and mus to the reference values
        /// determines results equal to reference for R(fx)
        /// </summary>
        [Test]
        public void Validate_pMC_DAW_ROfFx_zero_perturbation_one_layer_tissue()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                    new pMCROfFxDetectorInput
                    {
                        Fx=new DoubleRange(0.0, 0.5, 11),
                        PerturbedOps=new List<OpticalProperties>
                        { // perturbed ops
                            _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP,
                            _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                        },
                        PerturbedRegionsIndices=new List<int> { 1 },
                        TallySecondMoment = true
                    }
                },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();

            // validation value obtained from reference non-pMC run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx[1].Real - _referenceOutputOneLayerTissue.R_fx[1].Real), 0.00000000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx[1].Imaginary - _referenceOutputOneLayerTissue.R_fx[1].Imaginary), 0.00000000001);
            // validation value based on previous run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx[1].Real - 0.328865), 0.000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx[1].Imaginary - 0.083909), 0.000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx2[1].Real - 0.467357), 0.000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx2[1].Imaginary - 0.0), 0.000001); // imag of 2nd moment is 0
            Assert.AreEqual(89, postProcessedOutput.pMC_R_fx_TallyCount);
        }

        /// <summary>
        /// Test to validate that setting mua and mus to the perturbed values (mua*2, mus*1.1)
        /// determines results equal to linux results for R(fx)
        /// </summary>
        [Test]
        public void Validate_pMC_DAW_ROfFx_nonzero_perturbation_one_layer_tissue()
        {
            var postProcessor = new PhotonDatabasePostProcessor(
                VirtualBoundaryType.pMCDiffuseReflectance,
                new List<IDetectorInput>
                {
                        new pMCROfFxDetectorInput
                        {
                            Fx=new DoubleRange(0.0, 0.5, 11),
                            // set perturbed ops to reference ops
                            PerturbedOps=new List<OpticalProperties>
                            {
                                    _referenceInputOneLayerTissue.TissueInput.Regions[0].RegionOP,
                                    new(
                                        _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Mua * 2,
                                        _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.Musp * 1.1,
                                        _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.G,
                                        _referenceInputOneLayerTissue.TissueInput.Regions[1].RegionOP.N),
                                    _referenceInputOneLayerTissue.TissueInput.Regions[2].RegionOP
                                },
                            PerturbedRegionsIndices=new List<int> {1}
                         }            
                    },
                _databaseOneLayerTissue,
                _referenceInputOneLayerTissue);
            var postProcessedOutput = postProcessor.Run();
            // validation value obtained from prior run
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx[1].Real - 0.304018), 0.000001);
            Assert.Less(Math.Abs(postProcessedOutput.pMC_R_fx[1].Imaginary - 0.029895), 0.000001);
            Assert.AreEqual(89, postProcessedOutput.pMC_R_fx_TallyCount);
        }

        [Test]
        public void Test_Analog_absorption_weighting_type_throws_argument_exception()
        {
            var test1 = new DMuaDetectorTest();
            Assert.Throws<ArgumentException>(() =>
            {
                try
                {
                    test1.SetAbsorbAction(AbsorptionWeightingType.Analog);
                }
                catch (Exception e)
                {
                    Assert.AreEqual("Analog is not allowed with this detector (Parameter 'awt')", e.Message);
                    throw;
                }
            });
            var test2 = new DMusDetectorTest();
            Assert.Throws<ArgumentException>(() =>
            {
                try
                {
                    test2.SetAbsorbAction(AbsorptionWeightingType.Analog);
                }
                catch (Exception e)
                {
                    Assert.AreEqual("Analog is not allowed with this detector (Parameter 'awt')", e.Message);
                    throw;
                }
            });
        }

        /// <summary>
        /// Expose protected method in a new class that inherits the class under test
        /// </summary>
        public class DMuaDetectorTest : dMCdROfRhodMuaDetector
        {
            public new void SetAbsorbAction(AbsorptionWeightingType awt)
            {
                base.SetAbsorbAction(awt);
            }
        }

        /// <summary>
        /// Expose protected method in a new class that inherits the class under test
        /// </summary>
        public class DMusDetectorTest : dMCdROfRhodMusDetector
        {
            public new void SetAbsorbAction(AbsorptionWeightingType awt)
            {
                base.SetAbsorbAction(awt);
            }
        }

    }
}

